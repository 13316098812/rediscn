<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link href='/css/styles.css' rel='stylesheet' type='text/css' />
    <link href='/images/favicon.png' rel='shortcut icon' />
    <script src='/js/jquery.min.1.4.js'></script>
    <script src='/js/app.js'></script>
    <meta content='width=device-width, minimum-scale=1.0, maximum-scale=1.0' name='viewport' />
    <title>Redis中文资料站</title>
	<meta http-equiv="description" content="redis中文资料站，下载安装redis，查找redis常用命令（commands），选择适合的redis客户端方式，配置redis主从（master-slave），阅读redis官方文档，社区里了解更多redis信息，提交redis的bug。" />
  </head>
  <body class=''>
    <script src='/js/head.js'></script>
    <div class='text'>
      <article id='topic'>
        <h1>Redis配置</h1>
        
        
        <p>Redis可以在没有配置文件的情况下通过内建的配置文件来启动，但是这种启动方式只适用于开发和测试。</p>
        
        <p>合理的配置Redis的方式是提供一个Redis配置文件，这个文件通常叫做<code>redis.conf</code>。</p>
        
        <p><code>redis.conf</code>文件中包含了很多格式简单的指令如下：</p>
        
        <pre><code>关键字 参数1 参数2 ...参数N&#x000A;</code></pre>
        
        <p>如下是一个配置指令的示例：</p>
        
        <pre><code>slaveof 127.0.0.1 6380&#x000A;</code></pre>
        
        <p>也可以通过提供带有空格的字符串，或者带有双引号的参数，如下：</p>
        
        <pre><code>requirepass &quot;hello world&quot;&#x000A;</code></pre>
        
        <p>这些指令的配置，意义以及深入使用方法都能在每个Redis发布版本自带的的redis.conf文档中找到。</p>
        
        <ul>
        <li>自描述文档<a href="https://raw.github.com/antirez/redis/2.6/redis.conf">redis.conf for Redis 2.6</a>.</li>
        <li>自描述文档<a href="https://raw.github.com/antirez/redis/2.4/redis.conf">redis.conf for Redis 2.4</a>.</li>
        </ul>
        
        <h2>通过命令行传参</h2>
        
        <p>自Redis2.6起就可以直接通过命令行传递Redis配置参数。以下是一个例子：这个例子配置一个新运行并以6380为端口的
        Redis实例，使它成为127.0.0.1:6379Redis实例的slave。
        </p>
        
        <pre><code>./redis-server --port 6380 --slaveof 127.0.0.1 6379&#x000A;</code></pre>
        
        <p>通过命令行传递的配置参数的格式和redis.conf中设置的配置参数的格式完全一样，唯一不同的是需要在关键字之前加上
        前缀<code>--</code>。
        </p>
        
        <p>Note that internally this generates an in-memory temporary config file
        (possibly concatenating the config file passed by the user if any) where
        arguments are translated into the format of redis.conf.</p>
        
        <h2>Changing Redis configuration while the server is running</h2>
        
        <p>It is possible to reconfigure Redis on the fly without stopping and restarting
        the service, or querying the current configuration programmatically using the
        special commands <a href="/commands/config-set.html">CONFIG SET</a> and
        <a href="/commands/config-get.html">CONFIG GET</a></p>
        
        <p>Not all the configuration directives are supported in this way, but most
        are supported as expected. Please refer to the
        <a href="/commands/config-set.html">CONFIG SET</a> and <a href="/commands/config-get.html">CONFIG GET</a>
        pages for more information.</p>
        
        <p>Note that modifying the configuration on the fly <strong>has no effects on the
        redis.conf file</strong> so at the next restart of Redis the old configuration will
        be used instead.</p>
        
        <p>Make sure to also modify the <code>redis.conf</code> file accordingly to the configuration
        you set using <a href="/commands/config-set.html">CONFIG SET</a>.
        There are plans to provide a <code>CONFIG REWRITE</code>
        command that will be able to run the <code>redis.conf</code> file rewriting the
        configuration accordingly to the current server configuration, without modifying
        the comments and the structure of the current file.</p>
        
        <h2>Configuring Redis as a cache</h2>
        
        <p>If you plan to use Redis just as a cache where every key will have an
        expire set, you may consider using the following configuration instead
        (assuming a max memory limit of 2 megabytes as an example):</p>
        
        <pre><code>maxmemory 2mb&#x000A;maxmemory-policy allkeys-lru&#x000A;</code></pre>
        
        <p>In this configuration there is no need for the application to set a
        time to live for keys using the <a href="/commands/expire.html">EXPIRE</a> command (or equivalent) since
        all the keys will be evicted using an approximated LRU algorithm as long
        as we hit the 2 megabyte memory limit.</p>
        
        <p>This is more memory effective as setting expires on keys uses additional
        memory. Also an LRU behavior is usually to prefer compared to a fixed expire
        for every key, so that the <em>working set</em> of your data (the keys that are
        used more frequently) will likely last more.</p>
        
        <p>Basically in this configuration Redis acts in a similar way to memcached.</p>
        
        <p>When Redis is used as a cache in this way, if the application also requires
        the use Redis as a store, it is strongly suggested to create two Redis
        instances, one as a cache, configured in this way, and one as a store,
        configured accordingly to your persistence needs and only holding keys
        that are not about cached data.</p>
        
        <p><em>Note:</em> The user is adviced to read the example redis.conf to check how the
        other maxmemory policies available work.</p>
      </article>
    </div>
    <script src='/js/foot.js'></script>
  </body>
</html>
