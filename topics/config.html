<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link href='/css/styles.css' rel='stylesheet' type='text/css' />
    <link href='/images/favicon.png' rel='shortcut icon' />
    <script src='/js/jquery.min.1.4.js'></script>
    <script src='/js/app.js'></script>
    <meta content='width=device-width, minimum-scale=1.0, maximum-scale=1.0' name='viewport' />
    <title>Redis中文资料站</title>
	<meta http-equiv="description" content="redis中文资料站，下载安装redis，查找redis常用命令（commands），选择适合的redis客户端方式，配置redis主从（master-slave），阅读redis官方文档，社区里了解更多redis信息，提交redis的bug。" />
  </head>
  <body class=''>
    <script src='/js/head.js'></script>
    <div class='text'>
      <article id='topic'>
        <h1>Redis配置</h1>
        
        
        <p>Redis可以在没有配置文件的情况下通过内建的配置文件来启动，但是这种启动方式只适用于开发和测试。</p>
        
        <p>合理的配置Redis的方式是提供一个Redis配置文件，这个文件通常叫做<code>redis.conf</code>。</p>
        
        <p><code>redis.conf</code>文件中包含了很多格式简单的指令如下：</p>
        
        <pre><code>关键字 参数1 参数2 ...参数N&#x000A;</code></pre>
        
        <p>如下是一个配置指令的示例：</p>
        
        <pre><code>slaveof 127.0.0.1 6380&#x000A;</code></pre>
        
        <p>也可以通过提供带有空格的字符串，或者带有双引号的参数，如下：</p>
        
        <pre><code>requirepass &quot;hello world&quot;&#x000A;</code></pre>
        
        <p>这些指令的配置，意义以及深入使用方法都能在每个Redis发布版本自带的的redis.conf文档中找到。</p>
        
        <ul>
        <li>自描述文档<a href="https://raw.github.com/antirez/redis/2.6/redis.conf">redis.conf for Redis 2.6</a>.</li>
        <li>自描述文档<a href="https://raw.github.com/antirez/redis/2.4/redis.conf">redis.conf for Redis 2.4</a>.</li>
        </ul>
        
        <h2>通过命令行传参</h2>
        
        <p>自Redis2.6起就可以直接通过命令行传递Redis配置参数。以下是一个例子：这个例子配置一个新运行并以6380为端口的
        Redis实例，使它成为127.0.0.1:6379Redis实例的slave。
        </p>
        
        <pre><code>./redis-server --port 6380 --slaveof 127.0.0.1 6379&#x000A;</code></pre>
        
        <p>通过命令行传递的配置参数的格式和redis.conf中设置的配置参数的格式完全一样，唯一不同的是需要在关键字之前加上
        前缀<code>--</code>。
        </p>
        
        <p>需要注意的是通过命令行传递参数的过程会在内存中生成一个临时的配置文件(也许会直接追加在
        命令指定的配置文件后面)，这些传递的参数也会转化为跟Redis配置文件一样的形式。
        </p>
        
        <h2>在Redis服务器运行时更改配置</h2>
        
        <p>It is possible to reconfigure Redis on the fly without stopping and restarting
        the service, or querying the current configuration programmatically using the
        special commands <a href="/commands/config-set.html">CONFIG SET</a> and
        <a href="/commands/config-get.html">CONFIG GET</a></p>
        <p></p>
        
        <p>Not all the configuration directives are supported in this way, but most
        are supported as expected. Please refer to the
        <a href="/commands/config-set.html">CONFIG SET</a> and <a href="/commands/config-get.html">CONFIG GET</a>
        pages for more information.</p>
        <p></p>
        <p>需要注意的是在Redis运行时更改配置并不影响redis.conf，所以下次重启时Resis还会使用原来的配置。</p>
        
        <p>Make sure to also modify the <code>redis.conf</code> file accordingly to the configuration
        you set using <a href="/commands/config-set.html">CONFIG SET</a>.
        There are plans to provide a <code>CONFIG REWRITE</code>
        command that will be able to run the <code>redis.conf</code> file rewriting the
        configuration accordingly to the current server configuration, without modifying
        the comments and the structure of the current file.</p>
        
        <h2>配置Redis成为一个缓存</h2>
        
        
        <p>如果你想把Redis当做一个缓存来用，所有的key都有过期时间，那么你可以考虑
        使用以下设置（假设最大内存使用量为2M）：
        </p>
        
        <pre><code>maxmemory 2mb&#x000A;maxmemory-policy allkeys-lru&#x000A;</code></pre>
        
        
        <p>以上设置中并不需要我们的应用使用<a href="/commands/expire.html">EXPIRE</a>(或相似的命令)命令去设置每个key的过期时间，这是因为
       只要内存使用量到达2M，Redis就会使用类LRU算法删除某些key。
        </p>
        
        <p>This is more memory effective as setting expires on keys uses additional
        memory. Also an LRU behavior is usually to prefer compared to a fixed expire
        for every key, so that the <em>working set</em> of your data (the keys that are
        used more frequently) will likely last more.</p>
        <p></p>
        
        <p>基本上这么配置下的Redis可以当成memcached使用。</p>
        
        <p>When Redis is used as a cache in this way, if the application also requires
        the use Redis as a store, it is strongly suggested to create two Redis
        instances, one as a cache, configured in this way, and one as a store,
        configured accordingly to your persistence needs and only holding keys
        that are not about cached data.</p>
        
        <p><em>Note:</em> The user is adviced to read the example redis.conf to check how the
        other maxmemory policies available work.</p>
      </article>
    </div>
    <script src='/js/foot.js'></script>
  </body>
</html>
